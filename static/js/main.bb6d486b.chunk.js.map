{"version":3,"sources":["components/Card.module.css","App.module.css","components/Cards.module.css","components/Card.tsx","providers/FilterProvider.tsx","components/Cards.tsx","components/Header.tsx","App.tsx","serviceWorker.ts","index.tsx","components/Header.module.css"],"names":["module","exports","Card","props","card","getCardProperty","title","value","className","styles","property","imageWrapper","image","alt","name","src","imageUrl","properties","text","_","get","set","type","FilterContext","React","createContext","search","setSearch","FilterProvider","children","useState","Provider","CARDS_URL","Cards","useContext","loading","setLoading","cards","setCards","hasMore","setHasMore","pageRef","useRef","prevParamsRef","fetchCards","a","params","queryString","stringify","page","current","pageSize","console","log","fetch","response","json","responseObj","newCards","concat","Boolean","useEffect","cardComponents","map","key","id","wrapper","length","noResults","onChange","isVisible","visibilitySensor","spinner","Header","subTitle","filters","Consumer","searchInput","event","target","placeholder","App","app","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.bb6d486b.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"card\":\"Card_card__1QXam\",\"imageWrapper\":\"Card_imageWrapper__4GP5y\",\"image\":\"Card_image__1ZRtp\",\"properties\":\"Card_properties__2HwY1\",\"property\":\"Card_property__RQghZ\",\"title\":\"Card_title__32Ewi\",\"value\":\"Card_value__dx8oS\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"App_app__3zMx-\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"wrapper\":\"Cards_wrapper__3sC-z\",\"cards\":\"Cards_cards__1syr9\",\"noResults\":\"Cards_noResults__2gp3t\",\"loading\":\"Cards_loading__2jJfU\",\"spinner\":\"Cards_spinner__mg2dQ\",\"spin\":\"Cards_spin__38mws\",\"visibilitySensor\":\"Cards_visibilitySensor__RI9vq\"};","import styles from './Card.module.css';\r\nimport _ from 'lodash';\r\nimport React from 'react';\r\nimport { CardObj } from '../interfaces/cards';\r\n\r\ninterface CardProps {\r\n  card: CardObj;\r\n}\r\n\r\nconst Card: React.FC<CardProps> = props => {\r\n  const { card } = props;\r\n  if (!card) return null;\r\n\r\n  function getCardProperty(title: string, value: string) {\r\n    return (\r\n      <div className={styles.property}>\r\n        <div className={styles.title}>{title}</div>\r\n        <div className={styles.value}>{value || `(No ${title})`}</div>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  return (\r\n    <div className={styles.card}>\r\n      <div className={styles.imageWrapper}>\r\n        <img className={styles.image} alt={`${card.name} card`} src={card.imageUrl} />\r\n      </div>\r\n      <div className={styles.properties}>\r\n        {getCardProperty('Name', card.name)}\r\n        {getCardProperty('Text', card.text)}\r\n        {getCardProperty('Set Name', _.get(card.set, 'name'))}\r\n        {getCardProperty('Type', card.type)}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Card;\r\n","import React, { useState } from 'react';\r\n\r\ninterface FilterContextProps {\r\n  search: string;\r\n  setSearch: (value: string) => void;\r\n}\r\n\r\ninterface FilterProviderProps {\r\n  children: JSX.Element;\r\n}\r\n\r\nexport const FilterContext = React.createContext<FilterContextProps>({\r\n  search: '',\r\n  setSearch: () => {}\r\n});\r\n\r\nconst FilterProvider: React.FC<FilterProviderProps> = props => \r\n{\r\n  const { children } = props;\r\n\r\n  const [search, setSearch] = useState<string>('');\r\n\r\n  return (\r\n    <FilterContext.Provider value={{\r\n      search,\r\n      setSearch,\r\n    }}>\r\n      {children}\r\n    </FilterContext.Provider>\r\n  );\r\n};\r\n\r\nexport default FilterProvider;\r\n","import styles from './Cards.module.css';\r\nimport { CardObj, CardsResponse } from '../interfaces/cards';\r\nimport _ from 'lodash';\r\nimport queryString from 'query-string';\r\nimport React, { useState, useContext, useEffect, useRef } from 'react';\r\nimport VisibilitySensor from 'react-visibility-sensor';\r\nimport Card from './Card';\r\nimport { FilterContext } from '../providers/FilterProvider';\r\n\r\nconst CARDS_URL = 'https://api.elderscrollslegends.io/v1/cards';\r\n\r\nconst Cards: React.FC = () => {\r\n  const filtersContext = useContext(FilterContext);\r\n  const { search } = filtersContext;\r\n\r\n  const [loading, setLoading] = useState<boolean>(false);\r\n  const [cards, setCards] = useState<CardObj[]>([]);\r\n  const [hasMore, setHasMore] = useState<boolean>(false);\r\n\r\n  const pageRef = useRef<number>(1);\r\n  const prevParamsRef = useRef<string | null>(null);\r\n\r\n  async function fetchCards() {\r\n    const params = queryString.stringify({\r\n      page: pageRef.current,\r\n      pageSize: 20,\r\n      ...search && { name: search }\r\n    });\r\n   \r\n    // if the query params we are sending are for the request we just already made, do nothing and return\r\n    if (params === prevParamsRef.current) {\r\n      console.log('params are the same');\r\n      return;\r\n    }\r\n\r\n    prevParamsRef.current = params;\r\n\r\n    // if fetching the first page, clear the cards array while fetching, so loading indicator is at top of page\r\n    if (pageRef.current === 1) {\r\n      console.log('clearing cards');\r\n      setCards([]);\r\n    }\r\n   \r\n    setLoading(true);\r\n \r\n    try {\r\n      const response = await fetch(`${CARDS_URL}?${params}`)\r\n\r\n      // make sure that the params that were requested are still the ones for the most recent request, if not then\r\n      // we know another request was made after this one, so we can ignore the results. This will avoid race\r\n      // conditions and other odd behavior if multiple requests are in flight at the same time.\r\n      if (params !== prevParamsRef.current) {\r\n        return;\r\n      }\r\n\r\n      const responseObj: CardsResponse = await response.json();\r\n      const newCards = _.get(responseObj, 'cards');\r\n\r\n      if (pageRef.current === 1) {\r\n        setCards(newCards);\r\n      } else {\r\n        // if not the first page, add the new cards to the end of the old cards\r\n        setCards(cards.concat(newCards));\r\n      }\r\n\r\n      // The cards response has a next link if there are more items to fetch\r\n      setHasMore(Boolean(_.get(responseObj, ['_links', 'next'])));\r\n    } catch (error) {\r\n      // TODO: show error\r\n      setCards([]);\r\n      setHasMore(false);\r\n    }\r\n\r\n    setLoading(false);\r\n  }\r\n\r\n  useEffect(() => {\r\n    pageRef.current = 1;\r\n    fetchCards();\r\n  }, [search]);\r\n\r\n  const cardComponents = cards.map(card => <Card card={card} key={card.id} />)\r\n\r\n  return (\r\n    <div className={styles.wrapper}>\r\n      <div className={styles.cards}>\r\n        {!loading && !cards.length && (\r\n          <div className={styles.noResults}>No results.</div>\r\n        )}\r\n        {cardComponents}\r\n      </div>\r\n      {hasMore && !loading && (\r\n        <VisibilitySensor onChange={isVisible  => {\r\n          if (isVisible && !loading) {\r\n            pageRef.current = pageRef.current + 1;\r\n            fetchCards();\r\n          }\r\n        }}>\r\n          <div className={styles.visibilitySensor}>\r\n            Sensor\r\n          </div>\r\n        </VisibilitySensor>\r\n      )} \r\n      {(loading || hasMore) && (\r\n        <div className={styles.loading}>\r\n          <div className={styles.spinner} />\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Cards;\r\n","import styles from './Header.module.css';\r\nimport React from 'react';\r\nimport { FilterContext } from '../providers/FilterProvider';\r\n\r\nconst Header: React.FC = () => {\r\n  return (    \r\n    <header className={styles.Header}>\r\n      <div>\r\n        <div className={styles.title}>Elder Scross: Legendsâ„¢</div>\r\n        <div className={styles.subTitle}>Card Database</div>\r\n      </div>\r\n      <div className={styles.filters}>\r\n        <FilterContext.Consumer>\r\n          {({search, setSearch}) => (\r\n            <input\r\n              className={styles.searchInput}\r\n              onChange={event => setSearch(event.target.value)}\r\n              placeholder=\"Search\"\r\n              value={search}\r\n            />\r\n          )}\r\n        </FilterContext.Consumer>\r\n      </div>\r\n    </header>\r\n  );\r\n}\r\n\r\nexport default Header;\r\n","import styles from './App.module.css';\nimport React from 'react';\nimport Cards from './components/Cards';\nimport FilterProvider from './providers/FilterProvider';\nimport Header from './components/Header';\n\nconst App: React.FC = () => {\n  return (\n    <FilterProvider>\n      <div className={styles.app}>\n        <Header />\n        <Cards />\n      </div>\n    </FilterProvider>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Header\":\"Header_Header__206OW\",\"title\":\"Header_title__2qdds\",\"subTitle\":\"Header_subTitle__20eYL\",\"filters\":\"Header_filters__3N7W4\",\"searchInput\":\"Header_searchInput__2kJGk\"};"],"sourceRoot":""}